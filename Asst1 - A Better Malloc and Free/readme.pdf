In this program we implemented our own versions of malloc and free without actually dynamically allocating any memory.

We started by asking for an array of size 5000 bits using this array to model the memory we intended to “dynamically” allocate.  

We created a malloc function that we called mymalloc()  which took the size of memory we wanted to allocate as a parameter and returned a void pointer that pointed to the data that was stored.  In the malloc several smaller functions were implemented including initmem and organizemem().  Each data component stored in the array (memory) contained a meta data component that stored key attributed of the following data including whether it was in use (is_free), the size of the data chunk (size) and the next meta component in the array (*next).  

The very first time mymalloc is called it needs to create a meta component to initialize the array which is done in the initmem() function.  This function essentially sets free to  1(which means that chunk is free.  It also sets size to 5000-sizeof(meta) and the next pointer to NULL.  Next the entire array is traversed by going from one meta component to the next using the next pointer and checking the size of the memory that needs to be allocated against the size of the memory the meta is describing.  Once a piece of memory that is equivalent to or larger than the size needed break out of the while loop and if the size of the chunk is equivalent to the size needed we just return a pointer to the beginning of the data by casting the meta pointer to type void and increment it by the size of meta taking us to the beginning of the data component.  if the size of the current chunk is larger than the size necessary we first check to make sure that the chunk is greater than the size of the needed space+the size of meta and if so we proceed to splitting it.  We do this by first changing the size in the current meta component to the size needed and then incrementing to the end of the data component and creating a new meta component there setting free to 1 and the size to the original size-sizeof(meta) and manipulating the pointers to add the new meta into the “linked list”. Increment pointer by sizeof(meta) and return as a void pointer.

Our version of free is called my free and performs the basic functions of free and tries to manipulate memory as easily as possible to make sure there is maximum available space for the user to insert their structures.  This is done by first making sure that the pointer is within the bounds of the array and then making sure that the pointer actually is pointing to the beginning of a meta component.  This is checked by actually iterating through the entire array which is may not be the most efficient implementation, it was the most fool-proof method that would reduce the complexity of the code while still leaving very little room for error.  Once the pointer was checked and confirmed then the free attribute of the meta was changed to 1 (free).  After the free just to ensure that memory was optimized the function actually iterates through the entire array from meta to meta using next searching to see if it can find any two consecutive free chunks of memory.  If so the function merges the two into one by manipulating the pointers to delete the extra meta node and changes to size to include the space taken up by the extra meta and the space it represented.  The function also checks to make sure that the user is not freeing the same memory twice by following the pointer and checking it’s free attribute.

Overall the functions we implemented are very simplified versions of malloc an free allowing us to understand the basics of memory manipulation.

